import { ReadableStreamDefaultController } from 'stream/web';

import {
  ChatCompletionContentPart,
  ChatCompletionMessageBuilder,
  createChatCompletion
} from '@workspace/ai/openai';
import { EpicPrompts } from '@workspace/ai/prompts';
import { getSignedPublicAccessUrls } from '@workspace/aws/s3';
import { EpicStatus, Prisma } from '@workspace/database';
import { prisma } from '@workspace/database/client';

import { EpicDto } from '~/types/dtos/epic-dto';
import { StreamControllerState } from '../../types';

/**
 * Fetch all design files (and their sub-files) related to a given epic from the database.
 * @param epicId - ID of the epic to fetch design files for.
 * @returns A list of design files sorted by orderIndex.
 */
export async function getDesignFilesOfEpic(epicId: string) {
  const designFiles = await prisma.designFile.findMany({
    where: { epicId, parentFileId: null }, // Fetch only top-level design files (parentFileId is null)
    orderBy: { orderIndex: 'asc' }, // Sort by orderIndex in ascending order
    include: { subFiles: { orderBy: { orderIndex: 'asc' } } } // Include sub-files, sorted by orderIndex
  });
  return designFiles;
}

/**
 * Update the design flow documentation for a given design file.
 * @param designFileId - ID of the design file to update.
 * @param designFlowDoc - The new design flow document content.
 * @returns The updated design file.
 */
export async function updateDesignFlowDoc(
  designFileId: string,
  designFlowDoc: string
) {
  const updatedDesignFile = await prisma.designFile.update({
    where: { id: designFileId },
    data: { designFlowDoc }
  });

  return updatedDesignFile;
}

/**
 * Marks the epic as having completed the screen docs generation process.
 *
 * @param epicId - The unique identifier of the epic to update.
 * @returns The updated epic object after changing its status.
 */
export async function markEpicScreenDocsCompleted(epicId: string) {
  // Update the epic in the database by setting its status to 'SCREEN_DOCS_GENERATED'
  const updatedEpic = await prisma.epic.update({
    where: { id: epicId }, // Find the epic by its unique ID
    data: { status: EpicStatus.SCREEN_DOCS_GENERATED } // Update the status field
  });

  // Return the updated epic object
  return updatedEpic;
}

/**
 * Generate documentation for a single design file by sending the prompt and image to the AI model.
 * @param designFile - The design file to generate documentation for.
 * @param prompt - The prompt to guide AI content generation.
 * @param controller - Stream controller to send partial content back to the client in real-time.
 * @param controllerState - State to check if the stream is still open.
 * @returns The full design flow documentation generated by the AI.
 */
export async function generateDoc(
  designFile: Prisma.DesignFileGetPayload<{ include: { subFiles: true } }>,
  systemPrompt: string,
  context: string[],
  controller: ReadableStreamDefaultController,
  controllerState: StreamControllerState
) {
  let designFlowDoc = ''; // Accumulates the generated content

  // Get signed URL to access the design file image
  const [imageUrl, ...subImageUrls] = await getSignedPublicAccessUrls([
    { key: designFile.s3ObjectKey, downloadName: designFile.filename },
    ...designFile.subFiles.map((subFile) => ({
      key: subFile.s3ObjectKey,
      downloadName: subFile.filename
    }))
  ]);

  // Create a new ChatCompletionMessageBuilder instance to build messages for the AI model
  const messages = new ChatCompletionMessageBuilder()
    .addMessage({ role: 'system', content: systemPrompt }) // Add a system message with system-level instructions or context
    .addMessage({
      // Add assistant's previous responses or context to maintain conversation flow
      role: 'assistant',
      content: context.map((historyItem) => ({
        type: 'text',
        text: historyItem
      }))
    })
    .addMessage({
      // Add the user's message, including both text and an image URL
      role: 'user',
      content: [
        {
          // Include descriptive text about the image, using design file info
          type: 'text',
          text: `Image name - ${designFile.description} Screen Title - ${designFile.filename}`
        },
        {
          // Attach the image URL to provide visual context to the AI
          type: 'image_url',
          image_url: { url: imageUrl }
        },
        ...designFile.subFiles.flatMap<ChatCompletionContentPart>(
          (subFile, index) => {
            return [
              {
                // Include descriptive text about the image, using design file info
                type: 'text',
                text: `Image name - ${subFile.description} Screen Title - ${subFile.filename}`
              },
              {
                // Attach the image URL to provide visual context to the AI
                type: 'image_url',
                image_url: { url: subImageUrls[index] }
              }
            ];
          }
        )
      ]
    })
    .build();

  // Call AI to create chat completion, receiving response as a stream
  const response = await createChatCompletion(messages, 'gpt-4.1-2025-04-14');

  // Process each chunk of the streamed response
  for await (const chunk of response) {
    // Extract content from the chunk
    const content = chunk.choices[0]?.delta?.content;
    if (content) {
      // Append the content to the overall design flow doc
      designFlowDoc += content;

      // Stream the content back to the client if the controller is still open
      if (!controllerState.controllerClosed) controller.enqueue(content);
    }
  }

  return designFlowDoc;
}

export type Screen = {
  screenName: string;
  screenDescription: string;
  subScreens: Screen[];
  transcription?: string | null;
};

/**
 * Generate documentation for all screens and sub-screens within an epic.
 * @param epic - The epic containing design files to process.
 * @param controller - Stream controller to send updates back to the client.
 * @param controllerState - State to check if the stream is still open.
 */
export async function generateScreenDocs(
  epic: EpicDto,
  controller: ReadableStreamDefaultController,
  controllerState: StreamControllerState
) {
  // Fetch all design files related to the epic
  const designFiles = await getDesignFilesOfEpic(epic.id);
  const context: string[] = [];

  const screensForPrompt = designFiles.map((file) => {
    const subScreens = file.subFiles.map((subFile) => ({
      screenName: subFile.filename,
      screenDescription: subFile.description,
      subScreens: []
    }));
    const data: Screen = {
      screenName: file.filename,
      screenDescription: file.description,
      subScreens
    };
    if (file.backendLogicTranscription) {
      data.transcription = file.backendLogicTranscription;
    }
    return {
      ...data
    };
  });

  // High level prompt used for each screen
  const systemPrompt = EpicPrompts.Step4.getScreenDocSystemPrompt(
    epic.epicFlowDoc,
    screensForPrompt
  );

  /**
   * Iterate through each main screen and its sub-screens to generate documentation.
   */
  for (let mainIndex = 0; mainIndex < designFiles.length; mainIndex++) {
    const mainScreen = designFiles[mainIndex];
    const canSkipGeneration = mainScreen.designFlowDoc.trim() !== '';

    if (canSkipGeneration) {
      // If the main screen already has documentation, add it to the context
      context.push(mainScreen.designFlowDoc);
    } else {
      // Notify the client that documentation generation is starting for this main screen
      if (!controllerState.controllerClosed)
        controller.enqueue(JSON.stringify({ mainScreenId: mainScreen.id }));

      // Generate documentation for the main screen
      const designFlowDoc = await generateDoc(
        mainScreen,
        systemPrompt,
        context,
        controller,
        controllerState
      );

      context.push(designFlowDoc);
      // Update the main screen's design flow doc in the database
      await updateDesignFlowDoc(mainScreen.id, designFlowDoc);
    }

    /**
     * Iterate through sub-files (sub-screens) for the current main screen.
     */
    // for (let subIndex = 0; subIndex < mainScreen.subFiles.length; subIndex++) {
    //   const subScreen = mainScreen.subFiles[subIndex];
    //   const canSkipGeneration = subScreen.designFlowDoc.trim() !== '';

    //   if (canSkipGeneration) {
    //     // If the sub-screen already has documentation, add it to the context
    //     context.push(subScreen.designFlowDoc);
    //   } else {
    //     // Notify the client that documentation generation is starting for this sub-screen
    //     if (!controllerState.controllerClosed)
    //       controller.enqueue(
    //         JSON.stringify({
    //           mainScreenId: mainScreen.id,
    //           subScreenId: subScreen.id
    //         })
    //       );

    //     // Generate documentation for the sub-screen
    //     const designFlowDoc = await generateDoc(
    //       subScreen,
    //       systemPrompt,
    //       context,
    //       controller,
    //       controllerState
    //     );

    //     context.push(designFlowDoc);
    //     // Update the sub-screen's design flow doc in the database
    //     await updateDesignFlowDoc(subScreen.id, designFlowDoc);
    //   }
    // }
  }

  await markEpicScreenDocsCompleted(epic.id);
}
